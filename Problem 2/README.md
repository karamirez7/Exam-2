1. bestPath[i] = min(bestPath[3 + i - 1], bestPath[3 + i], bestPath[3 + i + 1]) + path[i] // as long as i is within range of array, and 3                                                                                               is replaced with the value of                                                                                                                path[0].length

2. This problem will be using an array to store previous solutions. The simplest case is one list where the best path at those last indices are the values itself. The problem will be worked on backwards starting from the last list of the given input with values being stored into the array from the end to the beginning. As we move from the last list to the first, the smallest new sum can be checked by comparing the i-1, i, and i+1 values stored in the array as obtained from the previous list. Each index of the created array will then store the best path to take (smallest distance) at that given position. The best path will be the min value between 0 and A[0].length

3. Problems were first worked out to better understand what needed to be done. I then examined the simplest case for input that is one list of values. If this is the simplest case, then it was recognized that these values can be used to look at the proceeding lists. 
